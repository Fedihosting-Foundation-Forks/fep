---
slug: "7952"
authors: Dmitri Zagidulin <@dmitri@social.coop>, bumblefudge <bumblefudge@learningproof.xyz>
status: DRAFT
dateReceived: 2024-06-20
discussionTo: https://socialhub.activitypub.rocks/t/fep-7952-roadmap-for-actor-and-object-portability/4332/
---
# FEP-7952: Roadmap For Actor and Object Portability

## Summary

**Portability**: A set of design choices, data models, and protocols, that
enable an end-user to automatically migrate from one service provider to another
_with the least amount of data loss and service disruption_, including the user's
social graph (Followers and Following collections, etc).

We focus on _automated_ migration because the option of extremely manual migration
always exists, such as re-typing all of one's messages and content, manually
re-adding everyone to one's following collection, manually contacting everyone
on one's former followers list and asking them to re-follow, and so on.
However, that's an extreme failure state; we want to avoid that.

This FEP targets two main categories of migration, covering user stories 1A-1F
and 2+3 in [FEP-73cd: User Migration Stories][FEP-73cd], respectively.
It also draws inspiration from an earlier information document, 
[FEP-cd47: Federation-friendly Addressing and Deduplication Use-Cases][FEP-cd47].

### Migration from a live (cooperating) server

Note that the data handling and formatting recommendations made here will be
strictly complementary to the in-progress [LOLA
proposal](https://swicg.github.io/activitypub-data-portability/lola.html),
which target the same user stories.

### Migration via backup/export produced by a dead (or non-cooperating) server

### Current Approaches

Most current Fediverse implementations tend to follow a pattern of comprehensive
service providers (**instances**) that bundle the following concerns into a
single service running on a web domain:

1. Identity hosting (hosting of the Actor profile object, which serves as the
   source of truth for all others in the list)
2. Authentication and authorship/provenance of objects
3. Key management (used for HTTP Signatures for Server to Server request authentication)
4. ActivityPub Object and Collection storage (typically in a database)
5. Message Transfer Services (hosting of inboxes and outboxes, delivering of
   outgoing objects, notifications, etc)
6. Instance-based content moderation
7. Community discovery (via the instance's Local feed)
8. Front-end clients, i.e. “website” and/or mobile app (most current
   implementations bundle the backend system with a made-for-purpose front end
   that runs off the same server)

This tight coupling of concerns makes automated migration extremely limited
when migrating from a live server, and impossible when migrating from a dead one.

For example, a typical current Move Actor implementation (such as the one
[implemented by Mastodon](https://docs.joinmastodon.org/spec/activitypub/#Move),
or specified in [FEP-7628](https://codeberg.org/fediverse/fep/src/branch/main/fep/7628/fep-7628.md))
only assists the user with automatically migrating their Followers list (by
setting up a bi-directional `alsoKnownAs` links and sending the `Move` activity
to all of their followers). In addition, some implementations allow the manual
export and re-import of the Following lists, mutes, blocks and bookmarks.
However, important content like posts, media attachments, reactions, reposts and
so on, does not get automatically transferred.

This FEP proposes a roadmap (a set of steps, design concepts, and recommendations)
that enables more complete live migrations, as well as enabling migrations from
dead server backups.

## Roadmap For Portability

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this specification are to
be interpreted as described in [RFC-2119][].

### 1. Unbundle the services and concerns of a typical instance

1. **Sign everything**: Recognize client-side cryptographic signatures as proof
   of authorship (by implementing [FEP-8b32: Object Integrity Proofs][FEP-8b32]),
   in addition to the current practice of relying solely on the instance URL.

2. **B.Y.O. Actor ID**: Using Object Integrity proofs enables Identity Hosting to
   be separated from the other instance concerns. Actor profiles can now be
   hosted separately from the instance (including as a static JSON object on a
   personal website), which in turn enables service providers to offer their
   users a “BYO (Bring Your Own) domain name” feature.

3. **Separate Inbox/Outbox**: (Optional) The previous steps enable message
   transfer and Inbox/Outbox hosting to be outsourced to separate service
   providers (the Actor profile links to these in the usual manner).

4. **Separate Object and Collection hosting**: (Optional) Similarly, AP Objects
   and Collections can now be stored on domains separate from the Actor's domain
   (since authorship and controller-ship can be proven cryptographically, in a
   domain-independent way). This enables the user to migrate storage service
   providers without having to change their Actor ID.

### 2. Implement Actor-relative URLs for objects

Decoupling of server functions and portability of account data are both served
by a more actor-centric addressing scheme, whereby Actor objects (specifically,
the various service providers they point to for each service) are assumed to be
changeable over time.
See [Implementing Actor-Relative URLs for Objects and
Collections](#2-implement-actor-relative-urls-for-objects) below for examples and details.

Such Actor-based URLs also enable a user to switch storage service providers
“invisibly”, without breaking existing links or functionality for any of the
other service providers listed above.

### 3. Create account export/import features that assume Actor-Relative URLs and segmented services

As long as a user's identity provider (which, again, can just be a static file
hosted publically) remains constant, they can migrate to different inbox/outbox
and storage providers, without breaking actor-relative links. That is, users will
be able to switch hosting and service providers to different domains, without
breaking signatures, replies and threading, likes, following and followers, or
anything else.
Exporting an account based on this model segments neatly and brings with it
verifiability if each object is separately signed by a key published in the
still-live Actor object.
Importing from such a file is trivial to implement compared to today's account
migrations that need to be aware of the data structures and addressing schemes
of the previous server.

### 4. Enable verifiable Actor URL migration

If the user wants to move their Actor to a different domain, or switch identity
hosting services, a future FEP could define this in a simple,  Verifiable
Credential-style data model containing attestations and proofs that the new
actor is equivalent to the old, controlled by the same subject, etc.
This would generalize and standardize one currently thorny requirement of
interoperable migration, that of authenticating migration requests.

Note: one possible extension of this authentication artefact would be to
incorporate "pre-rotation" style commitments of the sort used in distributed key
management.

### End Result: Stable, migration-aware distributed data

Taken together, these items allow for painless automated migration between
service providers, without broken links or effort duplication, and enables
restoration from backup and thus migration from dead servers.

## Unbundling Instances Into Separate Services

![diagram illustrating Instance -> unbundled](TODO)

Goal: For object ids to abstract and survive changes of service providers, for
some or all of the services that make up an account, including both categories
of migrations targetted.

To achieve this, the various services making up an instance must be able to be
extracted into separate standalone interchangeable services. For these services
to be interchangeable, however, the hosting of the Actor Object (and its `id`)
must be functionally independent from all other services.
This is because the Actor object authoritatively routes all inbound queries to
the other services, and thus, it needs to be easily updatable when the other
services change.

### Step 1: Extract Actor Profile Hosting Into Standalone Service

The first step in unbundling instances is to move out the Actor identity (and
profile hosting) into a standalone service, separate from inbox and object
hosting.

Requirements:

1. Make authorship proofs primarily cryptographic and thus potentially
2. independent of all other services if identity providers and authoring
3. service providers both support client-side signing:
  a. add verification key(s) to the Actor object via
     [FEP-521a](https://codeberg.org/fediverse/fep/src/branch/main/fep/521a/fep-521a.md)
  b. Sign individual activities using the same key(s), as specified in
     [FEP-8b32: Object Integrity Proofs](https://codeberg.org/fediverse/fep/src/branch/main/fep/8b32/fep-8b32.md)
2. Hosting Message Transfer Services (Inbox, Outbox) and special collections
   with side effects (Followers, Following etc) can now be managed separately

#### Example 1: Standalone ActivityPub Actor Profile

Hosted at `https://alice-personal-site.example/actor`

```json
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/multikey/v1",
    "https://w3id.org/fep/7952"
  ],
  "id": "https://alice-personal-site.example/actor",
  "type": "Person",
  "name": "Alice",
  "preferredUsername": "alice",
  "inbox": "https://service-provider.example/users/alice/inbox",
  "outbox": "https://service-provider.example/users/alice/outbox",
  "assertionMethod": [
     {
       "id": "https://alice-personal-site.example/actor#ed25519-key",
       "type": "Multikey",
       "controller": "https://alice-personal-site.example/actor",
        "publicKeyMultibase": "z6MkrJVnaZkeFzdQyMZu1cgjg7k1pZZ6pvBQ7XJPt4swbTQ2"
     }
  ],
  "service": [{
     "id": "https://alice-personal-site.example/actor#storage",
     "type": "CollectionStorage",
     "serviceEndpoint": "https://storage-provider.example/users/1234"
  }]
}
```

Things to note:

* The Actor profile's URL is hosted on `https://alice-personal-site.example/actor`,
  but the Inbox and Outbox services are hosted separately, at
  `https://service-provider.example/users/alice/inbox`
* The `assertionMethod` section, as defined in [FEP-521a: Representing actor's
  public keys](https://codeberg.org/fediverse/fep/src/branch/main/fep/521a/fep-521a.md).
* The `service` section, which sets up the ability to use Actor-Relative URLs
  for routing all requests to their current hosts. (This section reuses the
  notation from [Section 5.4 Services of the DID Core Specification](https://www.w3.org/TR/did-core/#services),
  but applies it to non-DID JSON objects in general.) This is described in Step 2
  (below) of the roadmap.

### Step 2: Extract Object and Collection Hosting Into Standalone Service

Given:

* An AP Actor profile that implements [FEP-521a: Representing actor's public keys](https://codeberg.org/fediverse/fep/src/branch/main/fep/521a/fep-521a.md)
* An AP Client that is able to perform [FEP-8b32: Object Integrity Proofs](https://codeberg.org/fediverse/fep/src/branch/main/fep/8b32/fep-8b32.md)
  to sign individual AP Objects and Activities.

These are sufficient pre-requisites to be able to prove authorship or
controller-ship of AP Objects and Activities cryptographically, without
requiring that they are hosted on the same web domain as the Actor's `id` URL.

This means that:

* Object and Collection hosting can now be extracted to general-purpose storage
  providers that are on different domains than the Actor profiles
* Actors can migrate between different storage providers without changing the
  Actor id and url.
* Moderation actions gain additional features for fine-grained handling of
  services distinct from individual objects:
  * Individual Actor IDs can be blocked/moderated, as is currently possible
  * Actor profile providers (in the example above,
    `https://alice-personal-site.example` or `https://example.com/users/alice`)
    can now also be blocked/moderated or accrue reputational weighting
  * Object-hosting or inbox providers (in the example below,
    `https://storage-provider.example`) might also be worth tracking separately
    for some moderation or spam-/sybil-protection use-cases.

#### Example 2: An AP Activity created by Alice from Example 1

`GET https://storage-provider.example/users/1234/AP/objects/5678`

returns:

```json
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "https://w3id.org/security/data-integrity/v1"
  ],
  "type": "Create",
  "id": "https://storage-provider.example/users/1234/AP/objects/5678",
  "actor": "https://alice-personal-site.example/actor",
  "object": {
    "type": "Note",
    "attributedTo": "https://alice-personal-site.example/actor",
    "content": "Hello world"
  },
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-jcs-2022",
    "verificationMethod": "https://alice-personal-site.example/actor#ed25519-key",
    "proofPurpose": "assertionMethod",
    "proofValue": "...",
    "created": "2023-02-24T23:36:38Z"
  }
}
```

The object is hosted on a different domain than the AP Actor, and authorship is
proved cryptographically.

### Step 3 (Optional): Extract Inbox Hosting and Message Processing Into Standalone Service

The [ActivityPub specification](https://www.w3.org/TR/activitypub/) already
requires that reserved Collections with special behaviors, such as Inbox, Outbox,
Followers, Following, Liked, etc., MUST all be discoverable through the Actor's
profile. Nothing in the specification precludes each of these special collections
being served on different domains from one another, or from the Actor object itself.

This means that nothing else needs to be changed, at the protocol level, to host
the various special collections on domains different from the Actor profile id's
domain.

Messaging and special collections service providers SHOULD implement the
[ActivityPub C2S (Client to Server)](https://www.w3.org/TR/activitypub/#client-to-server-interactions)
protocol, for maximum client interoperability.

#### Example Actor Profile with External Inbox and Outbox collections

```js
{
  "id": "https://alice-personal-site.example/actor",
  "inbox": "https://service-provider.example/users/alice/inbox",
  "outbox": "https://service-provider.example/users/alice/outbox",
  // …
}
```

### Authentication and Authorization Implications for Steps 2 and 3

Authentication and Authorization considerations for how clients and servers
would interact with externally hosted Objects and Collections is out of scope of
this FEP. Implementers are encouraged to follow current Fediverse best practices,
and use established authorization and authentication mechanisms such as:

* [OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749) tokens
* [HTTP Signatures][RFC-9421] - [CG Report](https://swicg.github.io/activitypub-http-signature/) in progress
* [Authorization Capabilities for Linked Data](https://w3c-ccg.github.io/zcap-spec/) specification or an
  equivalent capabilities method

## Implementing Actor-Relative URLs for Objects and Collections

Given:

* An AP Actor profile that implements [FEP-521a: Representing actor's public
  keys](https://codeberg.org/fediverse/fep/src/branch/main/fep/521a/fep-521a.md)
* An AP Client that is able to produce [FEP-8b32: Object Integrity
  Proofs](https://codeberg.org/fediverse/fep/src/branch/main/fep/8b32/fep-8b32.md)
  to sign individual AP Objects and Activities.
* The Actor profile `CollectionStorage` service endpoint introduced in this FEP
  below (which is a generalization of the DID Services endpoint mechanism)

We now have the required conditions to implement URL IDs for Objects and
Collections that do not change across service provider migrations.

### Actor-Relative URLs

> "All problems in computer science can be solved by another level of indirection" (the "fundamental theorem of software engineering")

-- Attributed to: Butler Lampson ([src](https://en.wikipedia.org/wiki/Indirection))

An Actor-Relative URL scheme that assumes abstracted and distinct services as
described above provides stable, portable URLs to AP Objects, Activities and
Collections, that have the following properties:

1. They are plain HTTP URL IDs, and can be used with existing HTTP client
2. infrastructure
2. Don't change when a user migrates to a storage service provider on a different
3. domain (as long as the Actor profile URL remains the same)

The basic mechanism works by making references to Objects as paths _relative to
the Actor Profile URL_, using query parameters or hash parameters.

To migrate to a different storage service provider, a simple automation triggered
by an authenticated intent from the Actor transfers the relevant Objects and
Collections to that new service provider (keeping their path and filename portion
the same), and updates the corresponding `CollectionStorage` service endpoint in
the Actor profile object.

#### Example 3: Object Storage Migration Using Actor-Relative URLs

Before migration, Alice uses the `https://old-storage-provider.example` as a
storage provider for her AP objects. She makes sure `https://old-storage-provider.example`
is specified as a service endpoint in her Actor profile.

`GET https://alice-personal-site.example/actor`

returns

```js
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/multikey/v1",
    "https://w3id.org/fep/7952"
  ],
  "id": "https://alice-personal-site.example/actor",
  "type": "Person",
  "service": [{
     "id": "https://alice-personal-site.example/actor#storage",
     "type": "CollectionStorage",
     "serviceEndpoint": "https://old-storage-provider.example"
  }],
  "assertionMethod": { /* … */ },
  // All the other profile properties …
}
```

And then creates a Note and stores it with the storage provider (making sure to
add an Object Identity Proof).

```HTTP
POST /AP/objects/
Host: old-storage-provider.example

{
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Note",
  "content": "This is a note",
  "attributedTo": "https://alice-personal-site.example/actor",
  "id": "https://alice-personal-site.example/actor?service=storage&relativeRef=/AP/objects/567",
  "proof": { /* FEP-8b32 Object Integrity proof goes here */ }
}
```

returns

```HTTP
HTTP 201 Created
Location: https://old-storage-provider.example/AP/objects/567
```

Note that this created Object can now be fetched at TWO different URLs:

1. The direct URL, `https://old-storage-provider.example/AP/objects/567`
2. The indirect Actor-Relative URL
   `https://alice-personal-site.example/actor?service=storage&relativeRef=/AP/objects/567`,
   by following the Fetching and Dereferencing algorithm (see below), which
   actually results in the direct URL.

When it comes time to migrate to a different service provider, the new one being
located at `https://brand-new-storage.example`, Alice performs the following steps.

She updates her Actor profile service endpoint, to point to the new provider,
so that it looks like this:

```HTTP
GET https://alice-personal-site.example/actor
```

returns

```json
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/multikey/v1",
    "https://w3id.org/fep/7952"
  ],
  "id": "https://alice-personal-site.example/actor",
  "type": "Person",
  "service": [{
     "id": "https://alice-personal-site.example/actor#storage",
     "type": "CollectionStorage",
     "serviceEndpoint": "https://brand-new-storage.example"
  }],
  "assertionMethod": { /* … */ },
  // All the other profile properties …
}
```

Note that the `serviceEndpoint` is the only property in the Actor profile that
has to change during migration.
Alice then transfers her Object to the new provider (for this example, she'll be
transferring the object individually, though in future FEPs, we expect
specification of APIs to transfer _all_ of the objects in one's storage):

```HTTP
POST /AP/objects/
Host: brand-new-storage.example

{
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Note",
  "content": "This is a note",
  "attributedTo": "https://alice-personal-site.example/actor",
  "id": "https://alice-personal-site.example/actor?service=storage&relativeRef=/AP/objects/567",
  "proof": { /* FEP-8b32 Object Integrity proof goes here */ }
}
```

returns:

```HTTP
HTTP 201 Created
Location: https://brand-new-storage.example/AP/objects/567
```

Notice that the object being stored at the new provider is byte-for-byte
identical to the object hosted at the old provider; its _indirect_ `id` and
contents do not change.
Now, Actor-Relative-URL-aware clients can dereference its `id` to the new
location residing at the `brand-new-storage.example` service provider (following
the Fetching and Dereferencing algorithm specified below).
Throughout this service provider migration, the external indirect `id` of the
object _does not change_, for the purposes of all other AP mechanisms such as
Inbox delivery, Likes and Reposts, and so on.
This greatly simplifies migration implementation, and reduces the side-effects
for moderation and graph health created by migration and server failures/deaths.

### The Actor Profile Service Endpoint Mechanism

This FEP introduces two new terms:

1. the `services` property of the Actor, which is modeled after the
   [services property](https://www.w3.org/TR/did-core/#services) in the [DID
   specification][DID], but generalized for all JSON objects and introduces no
   dependencies on DID semantics or tooling, and
2. the `CollectionStorage` service type for use in `services`, which is added to
   Actor Objects under the required relative service ID (i.e. fragment identifier)
   `#storage`.

See attached `context.jsonld`.

#### `service` Property

`service` - an OPTIONAL array of Service description objects.

Each Service Description object MUST have the following properties:

1. A `type`, corresponding with the service's type.
2. An `id` property
3. A `serviceEndpoint` property, pointing to the current service provider being
   used by the actor.

#### `CollectionStorage` Reserved Service Endpoint

This is a type of Service Description object used for general purpose ActivityPub
Object, Activity and Collection storage.

The `type` MUST be `CollectionStorage`.

The `id` (relative to the Actor profile) MUST be `storage`.

The `serviceEndpoint` URL points to the top level domain of the corresponding
service provider.

#### Example 4: Actor CollectionStorage Service Endpoint

```js
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/multikey/v1",
    "https://w3id.org/fep/7952"
  ],
  "service": [{
     "id": "https://alice-personal-site.example/actor#storage",
     "type": "CollectionStorage",
     "serviceEndpoint": "https://a-storage-provider.example"
  }],
  // Rest of the Actor profile goes here
}
```

### Actor-Relative URL Fetching and Dereferencing

#### Static Actor Object

For statically hosted actor profiles (which can be as simple as plain JSON files
hosted on Codeberg Pages or similar static file hosting providers), fragment
identifiers support two-part resolution:

`https://alice-personal-site.example/actor#service=storage&relativeRef=/AP/objects/567`

##### Resolution Procedure

1. Client does a GET to the URL without the hash fragment, (in this example
   `https://alice-personal-site.example/actor`).
2. Client receives the JSON object that is the actor profile.
3. Client can now dereference the actor-relative URL by:
4. Find the `service` section (if not found, throw a client-side error)
5. Find a service description object with the id referenced by the `service`
   hash parameter (here, `storage`)
6. Append the contents of the relativeRef hash parameter (here, `/AP/objects/567`)
   to the `id` of the storage service. Resulting in the valid direct URL
   `https://storage-provider.example/users/1234/AP/objects/567`
7. Make a GET HTTP call to the resulting URL to receive the AP Object for usual use.

#### Dynamic Actor Object

For dynamically hosted actor profiles (those able to process URL query
parameters), query parameters support two-part resolution:

`https://alice-personal-site.example/actor?service=storage&relativeRef=/AP/objects/567`

##### Resolution procedure

1.) Make a GET to that URL, profile host will do the actor-relative
dereferencing automatically with an http 302 redirect.

Example request:

```HTTP
HTTP GET /actor?service=storage&relativeRef=/AP/objects/567
Host: alice-personal-site.example
```

return

```HTTP
HTTP 302 Found
Location: https://storage-provider.example/users/1234/AP/objects/567
```

2.) Make a GET HTTP call to the returned URL to receive the AP Object for
usual use.

#### Fallback Mechanism

TODO - define JS redirect or some other mechanism for catching `?` requests and
turning them into `#` requests or vice versa, to error-proof the two types of
actor object being confused by client.

## Live and Dead Server Migrations (Keeping Actor ID Constant)

Actor-relative URLs allow for direct export of content to a static file format,
which can be authenticated at time of import with the client-managed key that
also signed the exported content.
Further research could be done on ergonomics, attack vectors, and corner-cases,
but the happy-path flow is quite simple and self-evident once these other changes
have been made.

## Migrating to a Different Actor ID

Web domains are already portable: a user can migrate between different domain
registrars and web hosting providers.

However, we recognize that individual domains are not practical for most of the
world population, due to high yearly domain registration fees and level of knowledge.
We expect that people will instead use actor profiles hosted on free service
providers, either as subdomains (example: `alice.provider.example`) or as paths
(example: `provider.example/users/alice`).

Because of this, Actor IDs (actor profile URLs) must also be portable.
To make this practical and automatable, future research is needed on a Verifiable
Credential-style portable attestation of the equivalence of two Actors, which
avoids requiring Actor Object hosting services to speak enough ActivityPub to
live-authenticate migration requests as currently required by the Move Actor flow.

### Example Actor Equivalence Attestation Object

TODO - possibly in separate FEP. Not strictly needed for the rest of this FEP to
be actionable.

## Appendix A: Current Portability Challenges

In today's implementations reliant on server-specific HTTPS URLs as IDs,
migration of content across servers involves the following steps:
An actor's ID and profile storage location changes, which means
followers/subscribers must be notified of the new identity
For each object that the actor controlled:
the ID of the object changes. (This has knock-on effects for threading,
reactions, moderation decisions, etc.) the storage location changes
authorship changes (knock-on effects for moderation, blocklists, reputation, etc.,
unless ported content makes available prior versions/authors in a standardized
way and/or moderation and reputation systems are made migration-aware)

Additionally, because moderation decisions are currently also tied to an
instance and by themselves are not portable/reusable, content potentially must
be re-moderated at the new instance.
There has been discussion on the Fediverse among people working on moderation
tooling for an abstraction that would help deduplication and track moderation of
objects across migrations, as bad actors tend to take more advantage of any and
all portability affordances than typical users.

## References

* [FEP-521a: Representing actor's public keys][FEP-521a]
* [FEP-73cd: Migration User Stories][FEP-73cd]
* [FEP-8b32: Object Integrity Proofs][FEP-8b32]
* [FEP-cd47: Federation-friendly Addressing and Deduplication Use-Cases][FEP-cd47]

* Christine Lemmer Webber, Jessica Tallon, [ActivityPub][AP], 2018
* S. Bradner, Key words for use in RFCs to Indicate Requirement Levels, 1997
* Dave Longley, Manu Sporny, [Verifiable Credential Data Integrity 1.0][DI for VCs], 2023
* Manu Sporny, Dave Longley, Markus Sabadell, Drummond Reed, Orie Steele,  Christopher Allen, [Decentralized Identifiers][DID] (DIDs) v1.0, 2022
* Dave Longley, Manu Sporny, [Data Integrity EdDSA Cryptosuites][DI Sigs] v1.0, 2023
* A. Rundgren, B. Jordan, S. Erdtman, [JSON Canonicalization Scheme][JCS] (JCS), 2020

[FEP-521a]: https://codeberg.org/fediverse/fep/src/branch/main/fep/521a/fep-521a.md
[FEP-73cd]: https://codeberg.org/fediverse/fep/src/branch/main/fep/73cd/fep-73cd.md#migration-user-stories
[FEP-8b32]: https://codeberg.org/fediverse/fep/src/branch/main/fep/8b32/fep-8b32.md
[FEP-cd47]: https://codeberg.org/fediverse/fep/src/branch/main/fep/cd47/fep-cd47.md

[AP]: https://www.w3.org/TR/activitypub/
[DI Sigs]: https://w3c.github.io/vc-di-eddsa/#eddsa-jcs-2022
[DI for VCs]: https://w3c.github.io/vc-data-integrity/
[DID]: https://www.w3.org/TR/did-core/
[JCS]: https://www.rfc-editor.org/rfc/rfc8785
[RFC-2119]: https://tools.ietf.org/html/rfc2119.html
[RFC-9421]: https://www.rfc-editor.org/rfc/rfc9421

## Copyright

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication

To the extent possible under law, the authors of this Fediverse Enhancement
Proposal have waived all copyright and related or neighboring rights to this work.
